# üöÄ Prompt: Refactor and Enhance `TemplateDesigner.tsx`

**Objective:** You are an expert React/TypeScript developer specializing in clean architecture and professional UI/UX design. Your task is to refactor the monolithic `src/components/TemplateDesigner.tsx` component into a modular, maintainable, and visually polished system, following the principles of Separation of Concerns (SoC).

---

## üìú **I. Core Principles & Requirements**

### **1. Separation of Concerns (SoC) - MANDATORY**
The current component mixes state management, UI logic, and side effects. Your primary goal is to separate these concerns:
- **State & Business Logic:** Consolidate all template-related state, actions (save, load, validate), and side effects into the `useTemplateData` hook. The components should be "dumb" and simply consume this hook.
- **UI Components:** Break down the UI into smaller, single-responsibility components. Each component should only be responsible for rendering a specific part of the UI and dispatching user events.
- **Container Component:** The main `src/components/TemplateDesigner.tsx` will become a "container" component, responsible only for composing the new child components and providing them with data and callbacks from the `useTemplateData` hook.

### **2. UI/UX Enhancement**
- **Professional & Clean:** The UI must be clean, modern, and intuitive. Use consistent spacing, typography, and visual hierarchy.
- **Interactivity:** Ensure all interactive elements have proper states (hover, focus, disabled, loading). Use subtle animations to improve the user experience.
- **Component Library:** Strictly use **Radix UI** for unstyled primitives (Tabs, Dialog, etc.) and **Lucide-react** for icons. Style everything with **Tailwind CSS**.

### **3. Code Quality & Architecture**
- **TypeScript:** Use TypeScript strictly. All props, state, and function signatures must be typed.
- **Modularity:** Create new files for the extracted components in a logical sub-directory structure (e.g., `src/components/template-designer/`).
- **Readability:** Code should be clean, well-organized, and easy to understand.

---

## üèóÔ∏è **II. Proposed Architecture & Refactoring Plan**

You will refactor `src/components/TemplateDesigner.tsx` by creating the following new components and enhancing the existing hook.

### **Step 1: Enhance `useTemplateData` Hook**
This hook will be the single source of truth. It should manage everything and expose a clean API.

**File:** `src/hooks/useTemplateData.ts`

**Exposed API (`return` value):**
```typescript
interface UseTemplateDataReturn {
  // State
  template: EducationalTemplate | null;
  templateDefinition: TemplateDefinition | null;
  bindings: DataBinding[];
  data: Record<string, any>;
  validation: ValidationReport | null;
  isDirty: boolean;
  isValid: boolean;
  isLoading: boolean;
  isSaving: boolean;
  isGenerating: boolean;
  canUndo: boolean;
  canRedo: boolean;
  historySize: number;
  isAutoSaveEnabled: boolean;
  lastAutoSave: number | null;
  lastSaved: number | null;
  errors: string[];
  warnings: string[];
  
  // Actions
  loadTemplate: (id: string) => Promise<boolean>;
  createTemplate: (name: string, category?: string) => Promise<boolean>;
  saveTemplate: () => Promise<boolean>;
  resetTemplate: () => void;
  updateTemplate: (updates: Partial<EducationalTemplate>) => void;
  updateMetadata: (metadata: Partial<TemplateDefinition['metadata']>) => void;
  updateBindings: (bindings: DataBinding[]) => void;
  updateData: (path: string, value: any) => void;
  updateDataBatch: (updates: Record<string, any>) => void;
  generateSampleData: () => void;
  validateTemplate: () => Promise<ValidationReport>;
  validateData: () => DataMappingResult;
  generatePreview: () => Promise<Uint8Array | null>;
  undo: () => boolean;
  redo: () => boolean;
  enableAutoSave: (intervalMs?: number) => void;
  disableAutoSave: () => void;
}
```

### **Step 2: Create New Child Components**

#### **A. `DesignerSidebar.tsx`**
This component will contain the entire left-hand sidebar, including the header, action buttons, and the tabs for Blocks, Properties, Data, and Library.

**File:** `src/components/template-designer/DesignerSidebar.tsx`
**Props:**
```typescript
interface DesignerSidebarProps {
  templateDefinition: TemplateDefinition | null;
  validation: ValidationReport | null;
  bindings: DataBinding[];
  data: Record<string, any>;
  isDirty: boolean;
  canUndo: boolean;
  canRedo: boolean;
  onMetadataChange: (updates: Partial<TemplateMetadata>) => void;
  onBlockSelect: (block: EducationalBlock) => void;
  onTemplateSelect: (templateDef: TemplateDefinition) => void;
  onNew: () => void;
  onLoad: () => void; // To open the template manager dialog
  onUndo: () => void;
  onRedo: () => void;
  onValidate: () => void;
}
```

#### **B. `DesignerToolbar.tsx`**
This component is the top bar above the main canvas.

**File:** `src/components/template-designer/DesignerToolbar.tsx`
**Props:**
```typescript
interface DesignerToolbarProps {
  templateName: string;
  isReady: boolean;
  isSaving: boolean;
  isGenerating: boolean;
  isDirty: boolean;
  lastAutoSave: number | null;
  onSave: () => void;
  onPreview: () => void;
  onExport: () => void;
}
```

#### **C. `DesignerCanvas.tsx`**
This component is a wrapper for the `pdfme` Designer instance. Its sole responsibility is to initialize and host the designer.

**File:** `src/components/template-designer/DesignerCanvas.tsx`
**Props:**
```typescript
interface DesignerCanvasProps {
  template: Template;
  onReady: (designer: Designer) => void; // Callback to pass the instance up
  onChange: (template: Template) => void; // Callback for when content changes
}
```

### **Step 3: Refactor `TemplateDesigner.tsx` (Container)**
The main component will now be clean and simple. It will:
1.  Call the `useTemplateData` hook.
2.  Manage UI state that is not part of the template data (e.g., `showPreviewDialog`, `showTemplateManagerDialog`).
3.  Render the new child components, passing them the necessary state and callbacks from the hook.

**File:** `src/components/TemplateDesigner.tsx`
**Structure:**
```tsx
export function TemplateDesigner(props) {
  const { /* all state and actions */ } = useTemplateData();
  const [designerInstance, setDesignerInstance] = useState(null);
  // ... other UI-specific state ...

  // Memoized callbacks to connect actions to UI components
  const handleSave = useCallback(() => { /* ... */ }, []);

  return (
    <div className="flex h-full">
      <DesignerSidebar {...propsForSidebar} />
      <div className="flex-1 flex flex-col">
        <DesignerToolbar {...propsForToolbar} />
        <main className="flex-1 p-4">
          {template && (
            <DesignerCanvas
              template={template}
              onReady={setDesignerInstance}
              onChange={updateTemplate}
            />
          )}
        </main>
      </div>
      {/* Dialogs for Preview and Template Manager */}
    </div>
  );
}
```

---

## üìö **III. Key Type Definitions (Reference)**

Provide these types as context. The AI must adhere to them.

```typescript
// from @pdfme/common
interface Template {
  basePdf: string | Uint8Array;
  schemas: Schema[][];
}

interface Schema {
  type: string;
  position: { x: number; y: number };
  width: number;
  height: number;
  content?: string;
  [key: string]: any; // Allow other properties
}

// from src/types/pdfme-extensions.ts
interface EducationalTemplate extends Template {
  schemas: EducationalSchema[][];
  educational?: {
    metadata?: any;
    category: 'quiz' | 'worksheet' | 'exam' | 'assignment' | 'handout' | 'assessment';
    subject?: string;
    gradeLevel?: string;
    duration?: number; // in minutes
    totalPoints?: number;
    passingScore?: number;
    instructions?: string;
    rubric?: RubricCriteria[];
    standards?: string[]; // Educational standards alignment
    keywords?: string[];
    learningObjectives?: string[];
    prerequisites?: string[];
    difficulty?: 'beginner' | 'intermediate' | 'advanced';
    language?: string;
    accessibility?: {
      largeText?: boolean;
      highContrast?: boolean;
      screenReader?: boolean;
    };
  };
  version?: {
    major: number;
    minor: number;
    patch: number;
    changelog?: string;
  };
  relationships?: {
    parentTemplate?: string;
    childTemplates?: string[];
    relatedTemplates?: string[];
  };
}

interface EducationalSchema extends Schema {
  type: EducationalSchemaType;
  educational?: {
    questionType?: QuestionType;
    correctAnswer?: string | string[];
    points?: number;
    difficulty?: 'easy' | 'medium' | 'hard';
    subject?: string;
    topic?: string;
    learningObjective?: string;
    instructions?: string;
    rubricCriteria?: RubricCriteria[];
    answerFormat?: 'text' | 'number' | 'date' | 'multiple-choice';
    requiresExplanation?: boolean;
    timeLimit?: number; // in minutes
    hints?: string[];
    tags?: string[];
  };
  validation?: {
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    customValidator?: (value: any) => boolean;
  };
  conditions?: {
    field: string;
    operator: 'equals' | 'contains' | 'greater' | 'less' | 'not-equals';
    value: any;
  }[];
  i18n?: {
    [languageCode: string]: {
      content?: string;
      placeholder?: string;
      instructions?: string;
    };
  };
}

type EducationalSchemaType =
  | "line"
  | "rectangle"
  | "text"
  | "image"
  | "table"
  | "multipleChoice"
  | "trueFalse"
  | "shortAnswer"
  | "essay"
  | "fillInBlank"
  | "matching"
  | "ranking"
  | "rubric"
  | "answerKey"
  | "header"
  | "footer"
  | "instructionBox"
  | "scoreBox"
  | "signature"
  | "date"
  | "qrcode"
  | "checkbox"
  | "radioGroup";

interface RubricCriteria {
  id: string;
  name: string;
  description: string;
  levels: RubricLevel[];
  weight?: number;
}

interface RubricLevel {
  score: number;
  label: string;
  description: string;
}

// from src/types/gemini.ts
interface GeminiAnalysisResponse {
  extractedQuestions: ExtractedQuestion[];
  documentStructure: DocumentStructure;
  extractedContent: ExtractedContent;
  processingInfo?: any;
  insights?: any;
  accessibility?: any;
}

interface ExtractedQuestion {
  id: string;
  number: string;
  content: string;
  type: QuestionType;
  options?: string[];
  correctAnswer?: string;
  points?: number;
  difficulty?: 'easy' | 'medium' | 'hard';
  tags?: string[];
  explanation?: string;
  hints?: string[];
  position?: PagePosition;
  confidence?: number;
  isEditing?: boolean;
  isDirty?: boolean;
  lastModified?: number;
  validationErrors?: string[];
  isValid?: boolean;
  metadata?: {
    estimatedTime?: number; // in minutes
    bloomsTaxonomy?: 'remember' | 'understand' | 'apply' | 'analyze' | 'evaluate' | 'create';
    learningObjectives?: string[];
  };
}

interface DocumentSection {
  id: string;
  title: string;
  type: string;
  content: string;
  position: PagePosition;
  confidence: number;
  formatting?: any;
  semanticRole?: 'title' | 'subtitle' | 'header' | 'instruction' | 'content' | 'note' | 'reference';
  level?: number;
  parentId?: string;
  children?: string[];
  language?: string;
  readabilityScore?: number;
  keywords?: string[];
  entities?: any[];
}

interface DocumentStructure {
  type: string;
  subject: string;
  difficulty?: 'beginner' | 'intermediate' | 'advanced';
  estimatedTime?: number; // in minutes
  language?: string;
  confidence: number;
  sections: DocumentSection[];
  metadata?: any;
  learningObjectives?: string[];
  prerequisites?: string[];
  assessment?: any;
  outline?: any[];
}

interface ExtractedContent {
  title: string;
  subtitle?: string;
  author?: string;
  date?: string;
  course?: string;
  instructions?: string;
  abstract?: string;
  keywords?: string[];
  learningOutcomes?: string[];
  prerequisites?: string[];
  materials?: string[];
  references?: string[];
  statistics?: any;
  quality?: any;
}

type QuestionType =
  | 'multiple_choice'
  | 'short_answer'
  | 'essay'
  | 'fill_blank'
  | 'true_false'
  | 'matching'
  | 'ordering'
  | 'numeric'
  | 'image_based';

interface PagePosition {
  page: number;
  x: number;
  y: number;
  width: number;
  height: number;
}

// from src/lib/data-binding.ts
interface DataBinding {
  id: string;
  label: string;
  description?: string;
  path: string; // Dot notation path, e.g., 'student.name'
  type: 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object';
  required: boolean;
  defaultValue?: any;
  example?: string;
  sourceSchemaId?: string; // ID of the schema field this binding is derived from
}

interface DataMappingResult {
  success: boolean;
  data: Record<string, any>;
  errors: string[];
  warnings: string[];
}

// from src/lib/template-manager.ts
interface TemplateMetadata {
  id: string;
  name: string;
  description: string;
  category: 'quiz' | 'worksheet' | 'exam' | 'general' | 'assignment' | 'handout';
  tags: string[];
  version: number;
  createdAt: number;
  updatedAt: number;
  thumbnail?: string; // Base64 image or URL
  createdBy?: string;
  lastModifiedBy?: string;
}

interface TemplateDefinition {
  metadata: TemplateMetadata;
  template: EducationalTemplate;
  dataBindings: DataBinding[];
  sampleData?: Record<string, any>;
  validationReport?: ValidationReport;
}

// from src/lib/template-validator.ts
interface ValidationIssue {
  id: string;
  severity: 'error' | 'warning' | 'info';
  message: string;
  path?: string; // Path to the schema item with the issue
  category: 'structure' | 'content' | 'design' | 'performance' | 'accessibility' | 'educational';
  suggestion?: string;
}

interface ValidationStatistics {
  totalElements: number;
  totalPages: number;
  totalQuestions: number;
  totalDataBindings: number;
  complexity: 'low' | 'medium' | 'high';
}

interface PerformanceMetrics {
  estimatedRenderTime: number; // in ms
  memoryUsage: 'low' | 'medium' | 'high';
  optimizationOpportunities: string[];
}

interface ValidationReport {
  isValid: boolean;
  score: number; // 0-100
  issues: ValidationIssue[];
  statistics: ValidationStatistics;
  suggestions: string[];
  performanceMetrics: PerformanceMetrics;
}

// from src/components/BlockLibrary.tsx
interface EducationalBlock {
  id: string;
  name: string;
  description: string;
  category: 'basic' | 'questions' | 'layout' | 'forms' | 'graphics';
  icon: React.ReactNode;
  schema: Schema; // The pdfme schema for this block
  tags: string[];
  isPremium?: boolean;
}

// Contextual information about key services/utilities
/*
  - `PdfmeIntegration` (src/lib/pdfme-integration.ts): Handles core PDFme functionalities like creating Designer/Form/Viewer instances, generating PDFs, and managing plugins/fonts. It acts as a wrapper around `@pdfme/ui` and `@pdfme/generator`.
  - `GeminiToPdfmeMapper` (src/lib/gemini-to-pdfme.ts): Converts the `GeminiAnalysisResponse` (from AI analysis) into a `pdfme` template structure, including schemas and data bindings.
  - `dataBindingService` (src/lib/data-binding.ts): Manages extraction of data bindings from templates, mapping data to template fields, and generating sample data.
  - `templateManager` (src/lib/template-manager.ts): Provides CRUD operations for `TemplateDefinition` objects, persisting them in local storage.
  - `templateValidator` (src/lib/template-validator.ts): Analyzes a `pdfme` template for structural, content, design, and educational issues, providing a `ValidationReport`.
  - `educational-plugins` (src/lib/educational-plugins.ts): Defines custom `pdfme` plugins for educational content types (e.g., multiple choice, essay questions) that extend `pdfme`'s core capabilities.
*/
```

---

## ‚úÖ **Final Output**

The final result should be a set of clean, modular, and reusable React components. The main `src/components/TemplateDesigner.tsx` should be a simple container, with all complex logic and UI properly separated into the `useTemplateData` hook and the new child components. The overall UI should feel professional and polished.
