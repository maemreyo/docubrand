# Phân Tích Nguyên Nhân Re-render Plugin Multiple-Choice

## Tóm tắt vấn đề

Khi người dùng gõ vào một trường `input` để chỉnh sửa các câu trả lời (options) trong plugin `@src/lib/educational-plugins/multiple-choice/`, toàn bộ component editor sẽ bị "re-render" (vẽ lại). Điều này làm mất focus khỏi `input` và khiến việc gõ chữ không thể tiếp tục.

## Phân tích chi tiết luồng sự kiện

Dưới đây là quá trình từng bước giải thích tại sao việc re-render lại xảy ra, dựa trên mã nguồn được cung cấp.

### 1. Nơi bắt đầu: Người dùng nhập liệu

- Người dùng tương tác với một phần tử `<input type="text">`.
- Phần tử `input` này được tạo ra bởi hàm `createOptionInput` trong file `editor.ts`.

### 2. Trình xử lý sự kiện `input` được kích hoạt

- Trong hàm `createOptionInput`, một trình lắng nghe sự kiện (event listener) được gắn vào mỗi `input`:
  ```typescript
  // File: @src/lib/educational-plugins/multiple-choice/components/editor.ts

  const handleInput = () => {
    const newOptions = [...allOptions];
    newOptions[index] = input.value;
    changeHandler("options", newOptions); // <-- Điểm mấu chốt
  };

  cleanup.addListener(input, "input", handleInput);
  ```
- Mỗi khi người dùng gõ một ký tự (`input` event), hàm `handleInput` sẽ được gọi.

### 3. Hàm `changeHandler` được gọi

- Bên trong `handleInput`, một mảng `newOptions` mới được tạo ra bằng cách sao chép mảng cũ và cập nhật giá trị tại vị trí (`index`) tương ứng.
- Quan trọng nhất, nó gọi hàm `changeHandler` với hai tham số: `key` là `"options"` và `value` là mảng `newOptions` mới.

### 4. `changeHandler` thông báo cho Component Cha

- `changeHandler` là một hàm được tạo ra bởi `createChangeHandler` trong `utils.ts`. Nhiệm vụ của nó là gọi callback `onChange` đã được truyền vào từ bên ngoài.
  ```typescript
  // File: @src/lib/educational-plugins/multiple-choice/utils.ts

  export const createChangeHandler = (
    onChange: ((props: { key: string; value: any }) => void) | undefined
  ): ChangeHandler => {
    return (key: string, value: any) => {
      if (onChange) {
        onChange({ key, value }); // <-- Gọi callback của component cha
      }
    };
  };
  ```
- `createEditorComponent` nhận `onChange` như một prop. Đây là cơ chế để plugin giao tiếp ngược lại với ứng dụng chính (host application) đang chứa nó.

### 5. Vòng lặp phá hủy và tái tạo (The Re-render Loop)

Đây là trung tâm của vấn đề:

1.  **Gửi thay đổi:** Plugin `MultipleChoiceEditor` gửi đi một sự kiện `onChange` trên mỗi lần nhấn phím.
2.  **Component Cha nhận thay đổi:** Một component cấp cao hơn (không có trong code được cung cấp, nhưng có thể suy luận ra) đang lắng nghe sự kiện `onChange` này. Component này chịu trách nhiệm quản lý trạng thái (state) của toàn bộ tài liệu hoặc template.
3.  **Cập nhật trạng thái:** Khi nhận được dữ liệu mới (mảng `options` mới), component cha sẽ cập nhật trạng thái của nó.
4.  **Kích hoạt Re-render:** Việc cập nhật trạng thái này (ví dụ trong React, Vue, hoặc một hệ thống tương tự) sẽ khiến component cha phải "re-render" lại các thành phần con của nó để phản ánh trạng thái mới.
5.  **Tái tạo Plugin:** Trong quá trình re-render, component cha sẽ gọi lại hàm `createEditorComponent` để tạo ra một phiên bản *hoàn toàn mới* của editor. Lệnh `rootElement.innerHTML = "";` ở đầu hàm `createEditorComponent` đã chứng minh điều này. Nó xóa sạch mọi thứ trong DOM trước khi vẽ lại.

## Kết luận

**Nguyên nhân gốc rễ:** Vấn đề không nằm ở việc "re-render" theo nghĩa là cập nhật DOM một cách thông minh. Vấn đề là **toàn bộ component editor bị phá hủy và được tạo lại từ đầu trên mỗi lần nhấn phím.**

- **Luồng gây lỗi:** `input` event -> `handleInput` -> `changeHandler` -> `onChange` prop -> Component cha cập nhật state -> Component cha gọi lại `createEditorComponent` -> `rootElement.innerHTML = ""` -> DOM cũ bị xóa -> DOM mới được tạo -> `input` mất focus.

- **Thiết kế:** Plugin được thiết kế theo kiểu "controlled component" (component được điều khiển), nghĩa là nó không có trạng thái nội bộ mà phụ thuộc hoàn toàn vào props được truyền vào. Mặc dù đây là một pattern phổ biến, việc kích hoạt `onChange` trên mỗi ký tự (`input` event) thay vì khi kết thúc chỉnh sửa (`blur` hoặc `change` event) kết hợp với việc component cha tái tạo toàn bộ plugin đã gây ra lỗi trải nghiệm người dùng nghiêm trọng này.
